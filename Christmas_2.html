<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Golden Christmas - Continuous Arc Edition</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Cinzel:wght@700&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Cinzel', serif;
            user-select: none;
        }

        #canvas-container {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1;
        }

        #title-layer {
            position: absolute; top: 8%; left: 0; width: 100%; text-align: center; z-index: 10; pointer-events: none;
        }

        h1 {
            margin: 0;
            font-family: 'Great Vibes', cursive;
            font-size: 6.5rem;
            background: linear-gradient(to bottom, #FFFFFF, #FFD700, #DAA520);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 30px rgba(255, 215, 0, 0.5));
            opacity: 0;
            animation: fadeIn 3s ease-out forwards 0.5s;
        }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(-30px); } to { opacity: 1; transform: translateY(0); } }

        #cam-preview {
            position: absolute; bottom: 20px; right: 20px; width: 180px; height: 135px; z-index: 20;
            border: 2px solid #FFD700; border-radius: 8px; overflow: hidden; background: #000;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.2); opacity: 0; transition: opacity 1s;
        }
        
        #webcam { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

        #ui-panel {
            position: absolute; bottom: 40px; left: 40px; z-index: 10;
            color: #D4AF37; background: rgba(5, 5, 5, 0.85); padding: 15px 20px;
            border-left: 4px solid #FFD700; backdrop-filter: blur(15px);
            min-width: 220px; border-radius: 0 12px 12px 0;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        .status-row { margin-bottom: 10px; font-size: 0.9rem; display: flex; align-items: center; }
        .status-row:last-child { margin-bottom: 0; }
        .icon { width: 30px; text-align: center; margin-right: 8px; font-size: 1.2rem; }
        .highlight { color: #FFF; font-weight: bold; text-shadow: 0 0 12px #FFD700; }
        
        #fullscreen-btn {
            position: absolute; top: 30px; right: 30px; z-index: 30;
            background: transparent; border: 1px solid #FFD700; color: #FFD700;
            padding: 10px 25px; cursor: pointer; font-family: 'Cinzel', serif;
            text-transform: uppercase; letter-spacing: 2px; transition: 0.3s; font-size: 0.8rem;
        }
        #fullscreen-btn:hover { background: #FFD700; color: #000; box-shadow: 0 0 20px #FFD700; }

        .control-btn {
            margin-top: 10px; width: 100%; padding: 10px;
            border: none; color: #000; font-family: 'Cinzel', serif; font-weight: bold;
            cursor: pointer; transition: 0.3s; font-size: 0.9rem;
        }
        
        #upload-btn { background: linear-gradient(45deg, #FFD700, #DAA520); margin-top: 15px; }
        #upload-btn:hover { background: #FFF; box-shadow: 0 0 15px #FFD700; }
        
        #audio-btn { background: linear-gradient(45deg, #C0C0C0, #A9A9A9); }
        #audio-btn:hover { background: #FFF; box-shadow: 0 0 15px #C0C0C0; }

        #file-input { display: none; }
        #audio-input { display: none; }

        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #FFD700; transition: opacity 0.8s;
        }
        .spinner {
            width: 60px; height: 60px; border: 4px solid #333; border-top: 4px solid #FFD700;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

    <div id="loading">
        <div class="spinner"></div>
        <div style="font-size: 1.8rem; letter-spacing: 6px;">WINTER PALACE</div>
        <div style="font-size: 0.8rem; opacity: 0.6; margin-top: 10px;">Accumulating Snow...</div>
    </div>

    <div id="title-layer">
        <h1>Merry Christmas!</h1>
    </div>

    <div id="cam-preview">
        <video id="webcam" autoplay playsinline></video>
    </div>

    <button id="fullscreen-btn">å…¨å±æ˜¾ç¤º</button>

    <div id="ui-panel">
        <div class="status-row">å½“å‰æ‰‹åŠ¿: <span id="gesture-text" class="highlight" style="margin-left: 10px">åˆå§‹åŒ–ä¸­...</span></div>
        <div class="status-row"><span class="icon">ğŸ–</span> <span>å¼ å¼€æ‰‹æŒ: æ—‹è½¬å›å¿†</span></div>
        <div class="status-row"><span class="icon">ğŸ‘Œ</span> <span>ä¿æŒæåˆ: è¿ç»­å±•ç¤º</span></div>
        <div class="status-row"><span class="icon">âœŠ</span> <span>æ¡ç´§æ‹³å¤´: èšåˆåœ£è¯æ ‘</span></div>
        
        <button id="upload-btn" class="control-btn">ä¸Šä¼ ç…§ç‰‡ (15å¼ )</button>
        <input type="file" id="file-input" multiple accept="image/*">

        <button id="audio-btn" class="control-btn">ä¸Šä¼ èƒŒæ™¯éŸ³ä¹ â™«</button>
        <input type="file" id="audio-input" accept="audio/*">
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
        import { FilesetResolver, GestureRecognizer } from '@mediapipe/tasks-vision';

        // --- 1. é…ç½® (Configuration) ---
        const TOTAL_PARTICLES = 6500;
        
        const RATIOS = {
            lights: 0.001, balls: 0.035, gifts: 0.04, canes: 0.03, 
            socks: 0.012, hats: 0.015
        };

        const CONFIG = {
            counts: {
                lights: Math.ceil(TOTAL_PARTICLES * RATIOS.lights),
                balls: Math.floor(TOTAL_PARTICLES * RATIOS.balls),
                gifts: Math.floor(TOTAL_PARTICLES * RATIOS.gifts),
                canes: Math.floor(TOTAL_PARTICLES * RATIOS.canes),
                socks: Math.floor(TOTAL_PARTICLES * RATIOS.socks),
                hats: Math.floor(TOTAL_PARTICLES * RATIOS.hats),
                needles: Math.floor(TOTAL_PARTICLES * 0.86),
                snow: 2500 
            },
            physics: {
                needle: 0.15, gift: 0.02, ball: 0.05, light: 0.09, common: 0.04
            },
            colors: {
                needle: 0x004225, gold: 0xFFD700, red: 0x8B0000,
                palette: [0xFFD700, 0xCC0000, 0x0022AA, 0xC0C0C0, 0x800080] 
            },
            tree: { height: 26, radius: 11 }
        };

        let viewState = 'TREE_SHAPE'; 
        let handData = { x: 0.5, y: 0.5, isActive: false, isPinching: false };
        let polaroids = [];
        const IMG_COUNT = 15;

        // è¿ç»­æŠ“å–ç›¸å…³é€»è¾‘å˜é‡
        let lastTriggerTime = 0;
        const TRIGGER_INTERVAL = 2.2; // æåˆæ—¶æ¯éš”1.2ç§’æŠ“ä¸€å¼ 

        // --- 2. åœºæ™¯åˆå§‹åŒ– ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); 

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 6, 65);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2; 
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = false;
        controls.maxDistance = 150;

        // å…‰æºè®¾ç½®
        const headLight = new THREE.SpotLight(0xFFF8E7, 1800);
        headLight.angle = 0.6; headLight.penumbra = 0.5; headLight.decay = 1.5; headLight.distance = 200;
        headLight.castShadow = true;
        camera.add(headLight); 
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0); 
        scene.add(ambientLight);

        const topLight = new THREE.DirectionalLight(0xffffff, 0); 
        topLight.position.set(0, 50, -20); 
        topLight.target.position.set(0, 0, 0);
        scene.add(topLight);
        scene.add(topLight.target);

        scene.add(camera); 

        const rimLight = new THREE.PointLight(0x445588, 250);
        rimLight.position.set(0, 20, -40);
        scene.add(rimLight);

        // --- 3. èµ„æºç”Ÿæˆ (çº¹ç†ä¸å‡ ä½•ä½“) ---
        function createGiftTexture(baseColor) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = baseColor; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            for(let i=0;i<100;i++) ctx.fillRect(Math.random()*128, Math.random()*128, 2, 2);
            ctx.fillStyle = '#FFD700'; 
            ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 4;
            ctx.fillRect(48, 0, 32, 128); ctx.fillRect(0, 48, 128, 32);
            return new THREE.CanvasTexture(canvas);
        }

        function createCandyTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#FFFFFF'; ctx.fillRect(0,0,64,64);
            ctx.fillStyle = '#CC0000';
            for(let i=-64; i<128; i+=16) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i+12, 0); ctx.lineTo(i-4, 64); ctx.lineTo(i-16, 64); ctx.fill();
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function createCandyGeo() {
            const path = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, -0.5, 0), new THREE.Vector3(0, 0.2, 0),
                new THREE.Vector3(0.15, 0.5, 0), new THREE.Vector3(0.35, 0.35, 0), new THREE.Vector3(0.35, 0.2, 0)
            ]);
            return new THREE.TubeGeometry(path, 12, 0.07, 8, false);
        }

        function createSockGeo() {
            const shape = new THREE.Shape();
            shape.moveTo(0,0); shape.lineTo(0.3,0); shape.lineTo(0.3,-0.6);
            shape.quadraticCurveTo(0.3,-0.9, 0.1,-0.9); shape.lineTo(-0.1,-0.9);
            shape.quadraticCurveTo(-0.3,-0.9,-0.3,-0.7); shape.quadraticCurveTo(-0.3,-0.5,-0.1,-0.5); shape.lineTo(0,-0.4);
            const geo = new THREE.ExtrudeGeometry(shape, { depth: 0.1, bevelEnabled:true, bevelThickness:0.03, bevelSegments:2 });
            const count = geo.attributes.position.count;
            const colors = new Float32Array(count * 3);
            const pos = geo.attributes.position;
            for(let i = 0; i < count; i++) {
                const y = pos.getY(i);
                if (y > -0.25) { 
                    colors[i*3] = 0.95; colors[i*3+1] = 0.95; colors[i*3+2] = 0.95;
                } else { 
                    colors[i*3] = 0.8; colors[i*3+1] = 0.05; colors[i*3+2] = 0.05;
                }
            }
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            return geo;
        }

        function createHatGeo() {
            const coneGeo = new THREE.ConeGeometry(0.3, 0.7, 16);
            coneGeo.translate(0, 0.35, 0); 
            const coneColors = new Float32Array(coneGeo.attributes.position.count * 3);
            for(let i=0; i<coneColors.length; i+=3) { coneColors[i]=0.8; coneColors[i+1]=0; coneColors[i+2]=0; }
            coneGeo.setAttribute('color', new THREE.BufferAttribute(coneColors, 3));
            const rimGeo = new THREE.TorusGeometry(0.3, 0.1, 8, 16);
            rimGeo.rotateX(Math.PI/2);
            const rimColors = new Float32Array(rimGeo.attributes.position.count * 3);
            for(let i=0; i<rimColors.length; i++) rimColors[i]=1;
            rimGeo.setAttribute('color', new THREE.BufferAttribute(rimColors, 3));
            const ballGeo = new THREE.SphereGeometry(0.1, 8, 8);
            ballGeo.translate(0, 0.7, 0);
            const ballColors = new Float32Array(ballGeo.attributes.position.count * 3);
            for(let i=0; i<ballColors.length; i++) ballColors[i]=1;
            ballGeo.setAttribute('color', new THREE.BufferAttribute(ballColors, 3));
            return BufferGeometryUtils.mergeGeometries([coneGeo, rimGeo, ballGeo]);
        }

        // --- 4. æ ¸å¿ƒç²’å­ç³»ç»Ÿ ---
        const particles = [];
        const dummy = new THREE.Object3D();
        const colorHelper = new THREE.Color();

        const getScatterPos = (radius) => {
            const r = radius * Math.cbrt(Math.random());
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            return new THREE.Vector3(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
        };

        function createParticles() {
            const needleGeo = new THREE.CylinderGeometry(0.02, 0.1, 0.9, 4);
            const needleMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.needle, roughness: 0.3, metalness: 0.2 });
            const needleMesh = new THREE.InstancedMesh(needleGeo, needleMat, CONFIG.counts.needles);
            scene.add(needleMesh);

            const giftGeo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
            const giftMat = new THREE.MeshStandardMaterial({ 
                map: createGiftTexture('#8B0000'), color: 0xffffff, roughness: 0.3, metalness: 0.2 
            });
            const giftMesh = new THREE.InstancedMesh(giftGeo, giftMat, CONFIG.counts.gifts);
            scene.add(giftMesh);

            const ballGeo = new THREE.SphereGeometry(0.5, 24, 24);
            const ballMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.05, metalness: 0.9 });
            const ballMesh = new THREE.InstancedMesh(ballGeo, ballMat, CONFIG.counts.balls);
            scene.add(ballMesh);

            const caneGeo = createCandyGeo();
            const caneMat = new THREE.MeshStandardMaterial({ map: createCandyTexture(), roughness: 0.4, metalness: 0.1 });
            const caneMesh = new THREE.InstancedMesh(caneGeo, caneMat, CONFIG.counts.canes);
            scene.add(caneMesh);

            const sockGeo = createSockGeo();
            const sockMat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.8, metalness: 0.1 });
            const sockMesh = new THREE.InstancedMesh(sockGeo, sockMat, CONFIG.counts.socks);
            scene.add(sockMesh);

            const hatGeo = createHatGeo();
            const hatMat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.8, metalness: 0.1 });
            const hatMesh = new THREE.InstancedMesh(hatGeo, hatMat, CONFIG.counts.hats);
            scene.add(hatMesh);

            const lightGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const lightMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 8.0 });
            const lightMesh = new THREE.InstancedMesh(lightGeo, lightMat, CONFIG.counts.lights);
            scene.add(lightMesh);

            const generate = (mesh, count, type, weight, hasColor) => {
                for (let i = 0; i < count; i++) {
                    if (hasColor) {
                        const hex = CONFIG.colors.palette[Math.floor(Math.random() * CONFIG.colors.palette.length)];
                        colorHelper.setHex(hex);
                        mesh.setColorAt(i, colorHelper);
                    }
                    const yNorm = i / count;
                    const rBase = CONFIG.tree.radius * (1 - yNorm);
                    let r = rBase + (Math.random()-0.5)*1.5;
                    let y = (yNorm * CONFIG.tree.height) - (CONFIG.tree.height/2);
                    const theta = i * 2.4 + Math.random();

                    let scale = 1;
                    if (type === 'gift') {
                        r = Math.random() * 9; y = -CONFIG.tree.height/2 + 1.5 + Math.random() * 3;
                        scale = 0.8 + Math.random() * 0.5;
                        if(i % 3 === 0) { colorHelper.setHex(0x2F4F4F); mesh.setColorAt(i, colorHelper); }
                        else if (i % 3 === 1) { colorHelper.setHex(0xB8860B); mesh.setColorAt(i, colorHelper); }
                    } else if (type === 'light') r = rBase * 1.1;

                    const treePos = new THREE.Vector3(r*Math.cos(theta), y, r*Math.sin(theta));
                    let scatterPos;
                    if (type === 'needle') scatterPos = getScatterPos(500);
                    else scatterPos = getScatterPos(50);

                    dummy.position.copy(scatterPos); dummy.updateMatrix(); mesh.setMatrixAt(i, dummy.matrix);

                    particles.push({
                        mesh, index: i, type, weight: weight * (0.8 + Math.random() * 0.4),
                        treePos, scatterPos, currentPos: scatterPos.clone(), baseScale: scale,
                        rotation: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0),
                        spinSpeed: { x: (Math.random()-0.5)*0.008, y: (Math.random()-0.5)*0.008 },
                        blinkPhase: Math.random()*Math.PI*2, blinkSpeed: 3 + Math.random()*3
                    });
                }
            };

            generate(needleMesh, CONFIG.counts.needles, 'needle', CONFIG.physics.needle, false);
            generate(giftMesh, CONFIG.counts.gifts, 'gift', CONFIG.physics.gift, true);
            generate(ballMesh, CONFIG.counts.balls, 'ball', CONFIG.physics.ball, true);
            generate(caneMesh, CONFIG.counts.canes, 'cane', CONFIG.physics.common, false);
            generate(sockMesh, CONFIG.counts.socks, 'sock', CONFIG.physics.common, true);
            generate(hatMesh, CONFIG.counts.hats, 'hat', CONFIG.physics.common, false);
            generate(lightMesh, CONFIG.counts.lights, 'light', CONFIG.physics.light, true);
        }
        createParticles();

        // --- 5. è¾…åŠ©å…ƒç´  ---
        const starShape = new THREE.Shape();
        const pts = 5;
        for(let i=0; i<pts*2; i++){
            const l = i%2==1 ? 0.6 : 1.5; const a = i/pts * Math.PI;
            starShape.lineTo(Math.cos(a)*l, Math.sin(a)*l);
        }
        const starGeo = new THREE.ExtrudeGeometry(starShape, {depth:0.4, bevelEnabled:true, bevelThickness:0.1, bevelSize:0.1, bevelSegments:2});
        const starMat = new THREE.MeshStandardMaterial({color: CONFIG.colors.gold, emissive: CONFIG.colors.gold, emissiveIntensity: 2.0, roughness:0.1, metalness:1.0});
        const starMesh = new THREE.Mesh(starGeo, starMat);
        starMesh.position.set(0, CONFIG.tree.height/2 + 1.5, 0);
        scene.add(starMesh);

        const ribbonPoints = []; const ribbonH = CONFIG.tree.height + 4;
        for(let i=0; i<150; i++) {
            const t = i/150; const angle = t * Math.PI * 12; const r = (1-t) * 13 + 1; const y = t * ribbonH - ribbonH/2 - 2;
            ribbonPoints.push(new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r));
        }
        const ribbonGeo = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(ribbonPoints), 100, 0.1, 8, false);
        const ribbonMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, emissive: CONFIG.colors.gold, emissiveIntensity: 3, transparent: true, opacity: 0.6 });
        const ribbonMesh = new THREE.Mesh(ribbonGeo, ribbonMat);
        scene.add(ribbonMesh);

        // --- 6. å›¾ç‰‡ä¸éŸ³é¢‘ä¸Šä¼  ---
        const uploadBtn = document.getElementById('upload-btn');
        const fileInput = document.getElementById('file-input');
        const audioBtn = document.getElementById('audio-btn');
        const audioInput = document.getElementById('audio-input');

        // éŸ³é¢‘ç›¸å…³
        const bgm = new Audio();
        bgm.loop = true;

        audioBtn.addEventListener('click', () => {
            audioInput.value = '';
            audioInput.click();
        });

        audioInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                bgm.src = url;
                bgm.play().then(() => {
                    audioBtn.innerText = "æ›´æ¢éŸ³ä¹ (æ’­æ”¾ä¸­)";
                    audioBtn.style.background = "#4CAF50";
                }).catch(err => {
                    console.error("Audio playback failed", err);
                    audioBtn.innerText = "æ’­æ”¾å¤±è´¥ï¼Œè¯·é‡è¯•";
                });
            }
        });

        // å›¾ç‰‡ç›¸å…³
        uploadBtn.addEventListener('click', () => {
            fileInput.value = ''; 
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files).slice(0, IMG_COUNT);
            if(files.length < 1) return;
            
            if(files.length !== IMG_COUNT) {
                alert(`ä¸ºäº†æœ€ä½³æ•ˆæœï¼Œè¯·å°½é‡é€‰æ‹© ${IMG_COUNT} å¼ ç…§ç‰‡ã€‚`);
            }

            polaroids.forEach(p => scene.remove(p.mesh));
            polaroids = [];
            uploadBtn.innerText = "å¤„ç†ä¸­...";

            const loader = new THREE.TextureLoader();
            let loadedCount = 0;

            files.forEach((file, i) => {
                const url = URL.createObjectURL(file);
                loader.load(url, (texture) => {
                    texture.colorSpace = THREE.SRGBColorSpace;
                    createPolaroid(texture, i);
                    loadedCount++;
                    if(loadedCount >= files.length) {
                        uploadBtn.innerText = "æ›´æ¢ç…§ç‰‡"; 
                        uploadBtn.style.background = "#4CAF50";
                    }
                });
            });
        });

        function createPolaroid(texture, index) {
            const frameGeo = new THREE.PlaneGeometry(1.6, 2.0); 
            const photoGeo = new THREE.PlaneGeometry(1.4, 1.4); 

            // ä¿®æ”¹æè´¨ï¼šå¢åŠ roughness(ç²—ç³™åº¦), å‡å°‘metalness(é‡‘å±åº¦)ä»¥é¿å…å¼ºçƒˆåå…‰
            const frameMat = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF, roughness: 0.85, metalness: 0.0, side: THREE.DoubleSide 
            });
            const photoMat = new THREE.MeshStandardMaterial({ 
                map: texture, roughness: 0.9, metalness: 0.0, side: THREE.DoubleSide 
            });

            const frameMesh = new THREE.Mesh(frameGeo, frameMat);
            const photoMesh = new THREE.Mesh(photoGeo, photoMat);
            photoMesh.position.z = 0.01; 
            photoMesh.position.y = 0.15; 

            const group = new THREE.Group();
            group.add(frameMesh);
            group.add(photoMesh);
            
            const groundR = 15 + Math.random() * 15;
            const groundAngle = Math.random() * Math.PI * 2;
            const groundY = -CONFIG.tree.height/2 + 0.1 + Math.random() * 0.5;
            const groundPos = new THREE.Vector3(Math.cos(groundAngle)*groundR, groundY, Math.sin(groundAngle)*groundR);
            const groundRot = new THREE.Euler(-Math.PI/2, 0, Math.random() * Math.PI * 2);

            scene.add(group);
            polaroids.push({
                mesh: group,
                groundPos: groundPos,
                groundRot: groundRot,
                index: index,
                // æ–°å¢çŠ¶æ€å±æ€§
                state: 'ORBIT', // ORBIT, CENTERING, SHOWING, EXITING
                showTimer: 0,
                exitRandomRot: {x:0, y:0, z:0},
                currentPos: new THREE.Vector3().copy(groundPos), 
                currentRot: new THREE.Quaternion().setFromEuler(groundRot)
            });
        }


        // --- 7. é«˜çº§ç§¯é›ªç³»ç»Ÿ ---
        const snowGeo = new THREE.BufferGeometry();
        const snowPos = new Float32Array(CONFIG.counts.snow * 3);
        const snowVel = new Float32Array(CONFIG.counts.snow);
        const snowData = [];
        const groundBaseY = -CONFIG.tree.height/2 - 1; 

        for(let i=0; i<CONFIG.counts.snow; i++) {
            const x = (Math.random()-0.5)*120;
            const z = (Math.random()-0.5)*120;
            const y = Math.random() * 80;
            
            snowPos[i*3] = x; snowPos[i*3+1] = y; snowPos[i*3+2] = z;
            snowVel[i] = 0.05 + Math.random() * 0.1;

            const dist = Math.sqrt(x*x + z*z);
            const pileHeight = 4.5 * Math.exp(-(dist*dist)/60); 
            const groundY = groundBaseY + Math.max(0, pileHeight) + (Math.random()*0.5);

            snowData.push({
                state: 0, groundY: groundY, origX: x, origZ: z
            });
        }
        snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
        const snowMat = new THREE.PointsMaterial({color:0xffffff, size:0.4, transparent:true, opacity:0.8, blending:THREE.AdditiveBlending});
        const snowSystem = new THREE.Points(snowGeo, snowMat);
        scene.add(snowSystem);

        // --- 8. AI & Post Processing ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.75; bloomPass.strength = 1.6; bloomPass.radius = 0.5;
        composer.addPass(bloomPass);

        const gestureText = document.getElementById('gesture-text');
        const video = document.getElementById('webcam');
        const camPreview = document.getElementById('cam-preview');

        async function initAI() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            const gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task", delegate: "GPU" },
                runningMode: "VIDEO"
            });

            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                video.addEventListener('loadeddata', () => {
                    document.getElementById('loading').style.opacity = 0;
                    camPreview.style.opacity = 1;
                    setTimeout(() => document.getElementById('loading').remove(), 800);

                    let lastTime = -1;
                    function predict() {
                        if (video.currentTime !== lastTime) {
                            const results = gestureRecognizer.recognizeForVideo(video, Date.now());
                            if (results.gestures.length > 0) {
                                const gestureName = results.gestures[0][0].categoryName;
                                const lm = results.landmarks[0];
                                
                                // çŠ¶æ€åˆ¤æ–­
                                if (gestureName === 'Closed_Fist') {
                                    viewState = 'TREE_SHAPE';
                                    handData.isPinching = false;
                                    gestureText.innerText = "æ¡æ‹³ (èšåˆ)";
                                } else if (viewState === 'SCATTERED') {
                                    let isPinch = false;
                                    if(lm) {
                                        const dist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                                        if (dist < 0.05) isPinch = true; 
                                    }

                                    if (isPinch) {
                                        handData.isPinching = true;
                                        gestureText.innerText = "æåˆ (è¿ç»­å±•ç¤º)";
                                    } else if (gestureName === 'Open_Palm') {
                                        handData.isPinching = false;
                                        gestureText.innerText = "å¼ å¼€æ‰‹æŒ (æ—‹è½¬)";
                                    } else {
                                        handData.isPinching = false;
                                        gestureText.innerText = "ç»´æŒçŠ¶æ€...";
                                    }
                                } else if (viewState === 'TREE_SHAPE' && gestureName === 'Open_Palm') {
                                    viewState = 'SCATTERED';
                                    handData.isPinching = false;
                                    gestureText.innerText = "å¼ å¼€æ‰‹æŒ";
                                }

                                gestureText.style.color = "#FFD700";

                                if (gestureName === 'Open_Palm' || gestureName === 'Closed_Fist' || handData.isPinching) {
                                    if (lm && lm[9]) {
                                        handData.isActive = true; handData.x = 1 - lm[9].x; handData.y = lm[9].y;
                                    }
                                } else handData.isActive = false;
                            } else {
                                handData.isActive = false; handData.isPinching = false;
                                gestureText.innerText = "æ‰«æä¸­..."; gestureText.style.color = "#666";
                            }
                            lastTime = video.currentTime;
                        }
                        requestAnimationFrame(predict);
                    }
                    predict();
                });
            }
        }
        initAI();

        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        });

        const clock = new THREE.Clock();
        let currentRingAngle = 0;

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            const isTree = viewState === 'TREE_SHAPE';

            controls.update();

            // ç¯å…‰è¿‡æ¸¡
            if (isTree) {
                headLight.intensity = THREE.MathUtils.lerp(headLight.intensity, 1800, 0.05);
                ambientLight.intensity = THREE.MathUtils.lerp(ambientLight.intensity, 0, 0.05);
                topLight.intensity = THREE.MathUtils.lerp(topLight.intensity, 0, 0.05);
            } else {
                headLight.intensity = THREE.MathUtils.lerp(headLight.intensity, 0, 0.05);
                ambientLight.intensity = THREE.MathUtils.lerp(ambientLight.intensity, 1.0, 0.05);
                topLight.intensity = THREE.MathUtils.lerp(topLight.intensity, 2.0, 0.05);
            }

            // æ‘„åƒæœºæ§åˆ¶
            if (handData.isActive) {
                const spherical = new THREE.Spherical().setFromVector3(camera.position);
                spherical.theta -= (handData.x - 0.5) * 0.05;
                spherical.phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, spherical.phi + (handData.y - 0.5) * 0.02));
                spherical.radius = THREE.MathUtils.clamp(spherical.radius + (handData.y - 0.5) * 0.1, 20, 150);
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 6, 0);
                controls.target.set(0, 6, 0);
            }

            // 1. Particle Updates
            particles.forEach(p => {
                let target = isTree ? p.treePos : p.scatterPos;
                if (!isTree && p.type !== 'needle') { dummy.rotation.x += p.spinSpeed.x; dummy.rotation.y += p.spinSpeed.y; }
                const floatScale = isTree ? 0 : 1;
                const fx = (p.type !== 'needle') ? Math.sin(time + p.index)*0.5*floatScale : 0;
                const fy = (p.type !== 'needle') ? Math.cos(time * 0.8 + p.index)*0.5*floatScale : 0;
                
                p.currentPos.x += (target.x + fx - p.currentPos.x) * p.weight;
                p.currentPos.y += (target.y + fy - p.currentPos.y) * p.weight;
                p.currentPos.z += (target.z - p.currentPos.z) * p.weight;
                
                dummy.position.copy(p.currentPos);
                if (isTree) {
                    if (p.type === 'needle') { dummy.lookAt(0, p.currentPos.y, 0); dummy.rotateX(-Math.PI/2); dummy.scale.setScalar(1); }
                    else if (p.type === 'gift') { dummy.rotation.set(0, p.index, 0); dummy.scale.setScalar(p.baseScale); }
                    else if (p.type === 'light') { dummy.rotation.copy(p.rotation); dummy.scale.setScalar(1 + 0.5 * Math.sin(time*p.blinkSpeed + p.blinkPhase)); }
                    else if (p.type === 'cane') { dummy.lookAt(0, p.currentPos.y, 0); dummy.rotateX(Math.PI/2); dummy.rotateZ(Math.PI); dummy.scale.setScalar(1); }
                    else if (p.type === 'hat') { dummy.rotation.set(0, p.index, 0); dummy.scale.setScalar(1); }
                    else { dummy.rotation.copy(p.rotation); dummy.scale.setScalar(1); }
                } else {
                    let s = (p.type === 'needle') ? 1 : 1.3; dummy.scale.setScalar(s);
                }
                dummy.updateMatrix(); p.mesh.setMatrixAt(p.index, dummy.matrix);
            });
            scene.traverse(o => { if(o.isInstancedMesh) o.instanceMatrix.needsUpdate = true; });

            // 2. Polaroid Updates (ç…§ç‰‡æ ¸å¿ƒé€»è¾‘)
            if (polaroids.length > 0) {
                // å¦‚æœæ˜¯æ ‘çŠ¶æ€ï¼Œæˆ–è€…æ²¡æœ‰åœ¨æåˆï¼Œåœ†ç¯æ—‹è½¬
                if (isTree || !handData.isPinching) {
                    currentRingAngle += delta * 0.1;
                }

                // è¿ç»­æŠ“å–è§¦å‘å™¨ï¼šå¦‚æœä¿æŒæåˆä¸”æ—¶é—´é—´éš”æ»¡è¶³
                if (!isTree && handData.isPinching && (time - lastTriggerTime > TRIGGER_INTERVAL)) {
                    // å¯»æ‰¾æœ€è¿‘çš„ä¸€ä¸ªå¤„äº ORBIT çŠ¶æ€çš„ç…§ç‰‡
                    let closestIdx = -1;
                    let minD = Infinity;
                    polaroids.forEach((p, i) => {
                        if (p.state === 'ORBIT') {
                            const d = p.mesh.position.distanceTo(camera.position);
                            if (d < minD) { minD = d; closestIdx = i; }
                        }
                    });

                    // è§¦å‘ç…§ç‰‡è¿›å…¥å±•ç¤ºæµç¨‹
                    if (closestIdx !== -1) {
                        polaroids[closestIdx].state = 'CENTERING';
                        lastTriggerTime = time;
                        // ç”Ÿæˆè¿™ä¸€å¼ ç…§ç‰‡ç‰¹æœ‰çš„éšæœºé£ç¦»å‚æ•°
                        polaroids[closestIdx].exitRandomRot = {
                            x: (Math.random() * 60 - 30) * (Math.PI/360),
                            y: (Math.random() - 0.5) * 4,
                            z: (Math.random() * 45) * (Math.PI/360)
                        };
                    }
                }

                const dynamicRadius = 30 + polaroids.length * 0.8;
                const camPos = camera.position;
                const center = new THREE.Vector3(0,0,0);
                const dirToCam = new THREE.Vector3().subVectors(camPos, center).normalize();
                const camRight = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), dirToCam).normalize();

                polaroids.forEach((p, i) => {
                    let targetPos, targetQuat, targetScale;
                    let lerpSpeed = 0.08;

                    if (isTree) {
                        // æ ‘æ¨¡å¼ï¼šå…¨å›åœ°é¢
                        targetPos = p.groundPos;
                        targetQuat = new THREE.Quaternion().setFromEuler(p.groundRot);
                        targetScale = 2.0; 
                        p.state = 'ORBIT'; // å¼ºåˆ¶é‡ç½®çŠ¶æ€
                    } else {
                        // æ•£å¼€æ¨¡å¼ï¼šæ ¹æ®çŠ¶æ€æœºå¤„ç†
                        if (p.state === 'ORBIT') {
                            const angle = (p.index / polaroids.length * Math.PI * 2) + currentRingAngle;
                            const rx = Math.cos(angle) * dynamicRadius;
                            const rz = Math.sin(angle) * dynamicRadius;
                            targetPos = new THREE.Vector3(rx, 5, rz);
                            const m = new THREE.Matrix4().lookAt(targetPos, new THREE.Vector3(0, 5, 0), new THREE.Vector3(0,1,0));
                            targetQuat = new THREE.Quaternion().setFromRotationMatrix(m);
                            targetScale = 6.0;

                        } else if (p.state === 'CENTERING') {
                            // é£å‘å±å¹•æ­£ä¸­å¿ƒ (æ‘„åƒæœºå‰æ–¹ 8 å•ä½)
                            targetPos = new THREE.Vector3().copy(camPos).add(dirToCam.clone().multiplyScalar(20)); 
                            // ç¨å¾®å‘ä¸‹ä¸€ç‚¹ï¼Œé¿å…æŒ¡ä½æ•´ä¸ªè§†é‡
                            targetPos.y -= 1.0; 

                            const m = new THREE.Matrix4().lookAt(targetPos, camPos, new THREE.Vector3(0,1,0));
                            targetQuat = new THREE.Quaternion().setFromRotationMatrix(m);
                            targetScale = 1.5; // åœ¨å±å¹•å‰ä¸éœ€è¦ç¼©æ”¾å¤ªå¤§
                            lerpSpeed = 0.12; // é£æ¥é€Ÿåº¦å¿«

                            // åˆ°è¾¾ä¸­å¿ƒåˆ¤å®š
                            if (p.currentPos.distanceTo(targetPos) < 0.5) {
                                p.state = 'SHOWING';
                                p.showTimer = time;
                            }

                        } else if (p.state === 'SHOWING') {
                            // ä¿æŒåœ¨ä¸­å¿ƒï¼Œè·Ÿéšæ‘„åƒæœºå¾®åŠ¨
                            targetPos = new THREE.Vector3().copy(camPos).add(dirToCam.clone().multiplyScalar(8));
                            targetPos.y -= 1.0;
                            const m = new THREE.Matrix4().lookAt(targetPos, camPos, new THREE.Vector3(0,1,0));
                            targetQuat = new THREE.Quaternion().setFromRotationMatrix(m);
                            targetScale = 1.5;
                            lerpSpeed = 0.5; // ç´§ç´§è·Ÿéš

                            // åœç•™æ—¶é—´æ£€æŸ¥ (0.6ç§’)
                            if (time - p.showTimer > 0.6) {
                                p.state = 'EXITING';
                            }

                        } else if (p.state === 'EXITING') {
                            // é£å‘ä¾§åæ–¹é«˜å¤„ (å¼§çº¿è½¨è¿¹æ¨¡æ‹Ÿ)
                            // ç›®æ ‡ï¼šæ‘„åƒæœºåæ–¹ 30 + å³ä¾§ 15 + ä¸Šæ–¹ 10
                            const exitVec = new THREE.Vector3()
                                .copy(dirToCam).multiplyScalar(30) // åæ–¹
                                .add(camRight.clone().multiplyScalar(15 * (i%2===0?1:-1))) // å·¦å³äº¤æ›¿
                                .add(new THREE.Vector3(0, 15, 0)); // ä¸Šæ–¹
                            
                            targetPos = new THREE.Vector3().copy(camPos).add(exitVec);

                            // æ—‹è½¬ï¼šç¿»æ»š
                            const m = new THREE.Matrix4().lookAt(targetPos, camPos, new THREE.Vector3(0,1,0));
                            const baseQuat = new THREE.Quaternion().setFromRotationMatrix(m);
                            const tumble = new THREE.Quaternion().setFromEuler(new THREE.Euler(
                                time * 2, // æŒç»­ç¿»æ»š
                                p.exitRandomRot.y, 
                                p.exitRandomRot.z
                            ));
                            targetQuat = baseQuat.multiply(tumble);
                            
                            targetScale = 8.0; 
                            lerpSpeed = 0.04; // é£èµ°é€Ÿåº¦é€‚ä¸­

                            // å¦‚æœé£è¿œäº†ï¼Œé‡ç½®å›è½¨é“
                            if (p.currentPos.distanceTo(camPos) > 60) {
                                p.state = 'ORBIT';
                            }
                        }
                    }

                    p.currentPos.lerp(targetPos, lerpSpeed);
                    p.mesh.position.copy(p.currentPos);

                    p.currentRot.slerp(targetQuat, lerpSpeed);
                    p.mesh.quaternion.copy(p.currentRot);

                    // åªæœ‰åœ¨é SHOWING çŠ¶æ€ä¸‹æ‰å¤§å¹…ç¼©æ”¾ï¼Œé¿å…ç³Šè„¸
                    if(p.state === 'SHOWING') {
                         p.mesh.scale.lerp(new THREE.Vector3(1.5, 1.5, 1.5), 0.1); // ä¿æŒçœŸå®æ¯”ä¾‹
                    } else {
                         p.mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), lerpSpeed);
                    }
                });
            }

            starMesh.rotation.y = time * 0.8; ribbonMesh.rotation.y = -time * 0.2;
            const sScale = isTree ? 1 : 0.01;
            starMesh.scale.lerp(new THREE.Vector3(sScale, sScale, sScale), 0.05);
            ribbonMesh.scale.lerp(new THREE.Vector3(sScale, sScale, sScale), 0.05);

            // 3. Snow System
            const positions = snowSystem.geometry.attributes.position.array;
            for(let i=0; i<CONFIG.counts.snow; i++) {
                const d = snowData[i];
                if (d.state === 1) { 
                    if (!isTree) {
                        positions[i*3+1] -= 0.3; 
                        if (positions[i*3+1] < -30) { d.state = 0; positions[i*3+1] = 60 + Math.random()*20; }
                    } else {
                        positions[i*3+1] = d.groundY; 
                        if (Math.random() < 0.002) { d.state = 0; positions[i*3+1] = 60 + Math.random()*20; }
                    }
                } else {
                    positions[i*3+1] -= snowVel[i];
                    if (isTree && positions[i*3+1] <= d.groundY) {
                        d.state = 1; positions[i*3+1] = d.groundY;
                    } 
                    else if (positions[i*3+1] < -30) {
                        positions[i*3+1] = 60 + Math.random()*20;
                        positions[i*3] = (Math.random()-0.5)*120; positions[i*3+2] = (Math.random()-0.5)*120;
                        const dist = Math.sqrt(positions[i*3]*positions[i*3] + positions[i*3+2]*positions[i*3+2]);
                        const pileHeight = 4.5 * Math.exp(-(dist*dist)/60);
                        d.groundY = groundBaseY + Math.max(0, pileHeight) + (Math.random()*0.5);
                    }
                }
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;

            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>